# CringeBoard Technology Overview

This document summarizes the technologies used across CringeBoard and compares each layer with common alternatives to clarify why the current stack fits the project as of 28 January 2026.

## Frontend
Technology: React 18 + Vite 7 (SPA, ESM dev server, Rollup prod build).

- Strengths: sub‑second cold starts and fast HMR, lean build output, minimal framework lock‑in, easy integration with API-driven UI.
- Compared:
  - Next.js / Remix: add SSR/ISR and routing opinionation; valuable for SEO-heavy or multi-tenant apps, but unnecessary for the current SPA footprint.
  - Create React App / webpack: slower dev/build loops (often 3–6× slower) and heavier configs for code-splitting/preloading.
  - Angular: batteries-included but steeper learning curve and larger bundles for a simple reader UI.

## Backend
Technology: FastAPI + Uvicorn (async Python 3.13).

- Strengths: type-driven request/response validation via Pydantic, autogenerated OpenAPI docs, async-first stack that matches feed fetching and caching, quick container cold starts.
- Compared:
  - Express.js: mature ecosystem but lower JSON throughput (~20–25k RPS typical bench vs ~35–45k for FastAPI on similar hardware) and weaker type safety without extra tooling.
  - Django / Flask: strong batteries and admin, but synchronous by default and heavier for high-concurrency IO unless paired with extra async layers.
  - Node Fastify / NestJS: competitive throughput, but the team is already standardized on Python for aggregation and scheduling logic.

## Data Layer
Technology: PostgreSQL 16 (alpine) + Redis 7 (alpine).

- PostgreSQL: robust SQL plus JSONB and full-text search, strong indexing, and reliable tooling; alpine image keeps pull size small.
- Redis: sub‑millisecond cache for hot feeds, rate limits, and task metadata; rich data structures beyond simple key/value.
- Compared:
  - MySQL: solid OLTP but weaker JSON/FTS ergonomics for mixed document/relational data.
  - MongoDB: flexible documents but adds operational/consistency complexity and weaker relational joins we need for users/preferences.
  - Memcached: simple and fast but lacks lists/sets/streams useful for future feed features.

## Messaging / Scheduling
Technology: Python scheduler worker (cron-like loop) with Redis for coordination.

- Compared:
  - Celery / RQ: more features for retries and distributed workers; can be introduced when job volume grows.
  - Cloud schedulers (Cloud Tasks/EventsBridge): great for managed ops, but Compose-first local workflow is prioritized.

## Containers & Local Orchestration
Technology: Docker + Docker Compose.

- Strengths: single command to boot API, web, db, cache, scheduler; healthchecks gate dependencies; alpine bases keep images 2–3× smaller than slim defaults, improving CI pulls.
- Compared:
  - Kubernetes/Helm: powerful scaling and RBAC, but operational overhead is unnecessary for a small app; Compose remains simpler for dev/prod parity at current scale.
  - Podman: daemonless alternative; could be adopted later without rewriting compose files thanks to compatibility.

## CI/CD
Technology: GitHub Actions with caching for npm/pip layers; workflows run lint, tests, and Docker builds.

- Compared:
  - GitLab CI / CircleCI: similar capabilities; migration offers limited upside versus existing GH-hosted code and actions ecosystem.
  - Self-hosted runners: enable custom hardware but add maintenance; deferred until workload justifies it.

## Security & Config
Technology: dotenv-based config, CORS middleware on API, secrets injected via env vars in Compose.

- Compared:
  - Vault/Secrets Manager: stronger centralized secret rotation; considered when moving beyond local/CI into managed hosting.

## When to Revisit Choices
- Add SSR/SEO: reconsider Next.js/Remix or Astro for hybrid rendering.
- Higher job volume or reliability SLAs: adopt Celery/RQ with Redis or a managed queue (SQS/Pub/Sub).
- Multi-region or high-scale traffic: evaluate Kubernetes plus managed Postgres/Redis, add observability stack (Prometheus/Grafana/OpenTelemetry).
- Search-heavy features: tune Postgres FTS first; add Elasticsearch/OpenSearch only if relevancy/scale demands exceed Postgres capabilities.

## Quick Start Pointers
- Local dev: `docker compose -f docker-compose.yml -f docker-compose.dev.yml up --build`
- API docs: visit `/docs` on the API service.
- Frontend: `npm install && npm run dev` in `frontend/` for HMR; `npm run build` for production bundle.
